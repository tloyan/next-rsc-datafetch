# Server Actions

### ğŸ’¡ Comprendre les server actions

## ğŸ“ Tes notes

DÃ©taille ce que tu as appris ici,Â surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Dans les applications clients `React`, le client peut envoyer des donnÃ©es vers un serveur via des API REST par exemple. Cela nÃ©cessite de crÃ©er un `endpoint` http avec du code serveur pour exÃ©cuter lâ€™action sur le serveur.

Avec lâ€™arrivÃ©e des server actions, il est possible dâ€™interagir avec le backend plus facilement.

Les Server Actions sont des fonctions asynchrones exÃ©cutÃ©es sur le serveur. Elles peuvent Ãªtre utilisÃ©es dans les composants cÃ´tÃ© serveur et cÃ´tÃ© client pour gÃ©rer les soumissions de formulaires et les mutations de donnÃ©es dans les applications `Next.js`.

Il est possible dâ€™appeler des server actions depuis de composant Server ou Client.

- Appel depuis un RSC : une fonction `async` avec la directive `â€œuse serverâ€`

```tsx
// Server Component
export default function Page() {
  // Server Action
  async function create() {
    'use server'

    // ...
  }

  return (
    // ...
  )
}
```

- Appel depuis un RCC :

Il nâ€™est pas possible dâ€™inclure la directive `'use server'` dans un fichier client. Il faut donc crÃ©er les actions dans un fichier Ã  part contenant la directive `'use server'` . Exemple :

```tsx
//actions.ts
'use server'

export async function create() {
  // ...
}
```

```tsx
import { create } from '@/app/actions'

export function Button() {
  return (
    // ...
  )
}
```

ğŸ“‘ Le lien vers la doc [https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)

## Exercice

Dans cet exercice, nous avons un RSC qui appelle `getTodos` une liste de tÃ¢ches venant de notre base de donnÃ©es.

```tsx
//app/todos/page.tsx
const Page = async () => {
  const todos = await getTodos()
  return (
    <div className="mx-auto max-w-4xl p-6 text-lg">
      <h1 className="mb-4 text-center text-3xl font-bold">Todo</h1>
      <Todos todos={todos ?? []} />
    </div>
  )
}
```

ğŸ‘¨â€âœˆï¸ Hugo, le chef de projet, te demande dâ€™implÃ©menter lâ€™ajout de tÃ¢ches dans la base de donnÃ©es. Il te fournit une librairie contenant la fonction `addTodo` qui ajoute en base de donnÃ©es.

```tsx
import {addTodo as addTodoDao} from '@/db/sgbd'
//insertion
addTodoDao(todo) //

```

Pour simplifier lâ€™exercice, les vues sont dÃ©jÃ  crÃ©Ã©es : `todos-view` et `todo-item`.

- Dans un premier temps, essaie dâ€™implÃ©menter `addTodoDao` dans `todos-view`.
- Ensuite, dans le fichier `action.tsx`.

<aside>
ğŸ’¡ Note 1 : Pour simuler un temps de serveur long, nous avons configurÃ© dans `sgbd.ts`.

</aside>

```tsx
const slowConnexion = true
const serverResponseTime = 2000
```

<aside>
ğŸ’¡ Note 2 . Il est possible de supprimer `/src/db/db.json` pour avoir une BDD fraÃ®che

</aside>

Fichiers

- `exercises/todos/todo-view.tsx`
- `exercises/todos/action.tsx`

## Bonus

### 1. ğŸš€ GÃ©rer les erreurs

Il est important de gÃ©rer correctement les erreurs cÃ´tÃ© serveur. Pour cela, nous allons gÃ©nÃ©rer des erreurs alÃ©atoirement grÃ¢ce Ã  :

```tsx
//src/db/sgbd.ts
const randomError = true
```

Avec `sonner` , il est possible dâ€™afficher des toasts dâ€™erreur grÃ¢ce Ã  :

```tsx
 import {toast} from 'sonner'
 //
 toast.error(`Une erreur est survenue`)
```

ğŸ¶ Dans cet exercice, tu vas devoir gÃ©rer 2 types dâ€™erreurs.

- Une erreur client si la tÃ¢che est vide : â€œVeuillez entrer un nom de tÃ¢cheâ€.
- Une erreur en cas de problÃ¨me cÃ´tÃ© server action (utilise un `try..catch` pour cela).

Fichiers

- `exercises/todos/todo-view.tsx`

### 2. ğŸš€ Mise Ã  jour dâ€™une tÃ¢che (update server action)

ğŸ¶ Dans cet exercice, tu vas devoir implÃ©menter la mise Ã  jour de la tÃ¢che (completed ou non). Pour cela, tu as Ã  ta disposition une fonction `updateTodo` qui met Ã  jour la base de donnÃ©es.

```tsx
import {updateTodo as  updateTodoDao} from '@/db/sgbd'
//mise Ã  jour
updateTodoDao(todo) //
```

Tu as Ã©galement Ã  ta disposition `todo-item`, un component qui contient une `Checkbox`

```tsx
   const handleChange = async (isCompleted: boolean) => {
    console.log('isCompleted', isCompleted)
  }

 <Checkbox
    checked={todo.isCompleted}
    id={`${todo.id}`}
    onCheckedChange={(checked) => handleChange(checked as boolean)}
  />


```

- ğŸ¶ Dans un premier temps, crÃ©e le server action `updateTodo`
- ğŸ¶ Utilise le dans la vue en gÃ©rant Ã©galement les possibles erreurs.

Fichiers

- `exercises/todos/todo-item.tsx`
- `exercises/todos/action.tsx`

### 3. ğŸš€ Cache et revalidatePath

En mode dÃ©veloppement, le comportement nâ€™est pas identique Ã  celui dâ€™un `build` de production. Dans le cas de notre `Todo` App par exemple, lorsque lâ€™on met Ã  jour les donnÃ©es via un server action, le serveur rafraÃ®chit les donnÃ©es. Mais il faut faire attention car en production le fonctionnement est diffÃ¨rent. Il faut toujours vÃ©rifier les comportement avec un build de production :

```bash
npm build
npm start
```

En lanÃ§ant notre projet en mode production, on se rend compte que lors de lâ€™ajout /mise Ã  jour de donnÃ©es en BDD, les donnÃ©es ne sont pas mise Ã  jour Ã  lâ€™Ã©cran.

Explication :

- Lors du `build` de production, `next` va gÃ©nÃ©rer un fichier statique contenant le nombre de Todos en base de donnÃ©es dans le but dâ€™amÃ©liorer les performances.
- Lorsque des donnÃ©es sont modifiÃ©es, il faut spÃ©cifier Ã  `Next` de revalider (rÃ©gÃ©nÃ©rer) une page Ã  jour.

`Next` propose une gestion trÃ¨s fine du cache via lâ€™API cache et notamment `revalidatePath` qui permet de revalider un segment de route.

ğŸ“‘ Le lien vers la doc [https://nextjs.org/docs/app/api-reference/functions/revalidatePath](https://nextjs.org/docs/app/api-reference/functions/revalidatePath)

- ğŸ¶ Dans cet exercice, tu vas devoir faire en sorte que les donnÃ©es soient revalidÃ©es aprÃ¨s chaque mise Ã  jour. Tout ce passe dans `action.tsx`

Fichiers

- `exercises/todos/action.tsx`

### 4. ğŸš€ SÃ©rialisation

ğŸ¶ Hugo, le Chef de projet, te demande de valider le `title` de la tÃ¢che avec une `Regex` :

- Le titre doit commencer par une lettre majuscule.
- Le titre peut contenir des lettres, des chiffres, des espaces, des tirets (-) ou des `underscores` (\_).
- Le titre doit avoir une longueur minimale de 3 caractÃ¨res et maximale de 50 caractÃ¨res.

Il te fournit la `Regex` suivante :

```tsx
const titlePattern = /^[A-Z][A-Za-z0-9 _-]{2,49}$/;
const titlePattern = new RegExp(titlePattern);
!pattern.test(todo.title)
```

Il souhaite que la `Regex` puisse Ãªtre passÃ©e depuis le client et exÃ©cutÃ©e depuis le serveur.

- ğŸ¶ ImplÃ©mente le code suivant :

```tsx
//CLIENT CODE
const handleChange = async (isCompleted: boolean) => {
    const pattern = /^[A-Z][\w -]{2,49}$/
    const regex = new RegExp(pattern)
    try {
      await updateTodoAction(
        {
          ...todo,
          isCompleted,
        },
        regex
      )
    } catch (error) {
      toast.error(`Failed to update todo.${error}`)
    }
  }
//SERVER ACTION
export const updateTodo = async (todo: Todo, reg: RegExp) => {
  if (!reg.test(todo.title)) {
    throw new Error("Le titre de la tÃ¢che n'est pas valide.")
  }
  try {
    await updateTodoDao(todo)
  } catch (error) {
    console.error('Failed to update todo', error)
    throw error
  } finally {
    revalidatePath('/exercises/todos')
  }
}
```

Comme tu peux le constater, tu obtiens un message :

```tsx
Failed to update todo.Error: Only plain objects, and a few built-ins, can be passed to Server Actions. Classes or null prototypes are not supported
```

Ce qui est normal, car les paramÃ¨tres ne peuvent Ãªtre que des valeurs `sÃ©rialisable`

ğŸ“‘ doc [https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values)

ğŸ¶ Adapte le code en ne passant que cela en paramÃ¨tre du server action

**ğŸ¤–** `const pattern = /^[A-Z][\w -]{2,49}$/`

Et en instanciant la `Regex` cÃ´tÃ© server

### 5. ğŸš€ Revalidate

Les donnÃ©es en cache peuvent Ãªtre revalidÃ©es de 2 maniÃ¨res :

- De maniÃ¨re manuelle (exercice prÃ©cÃ©dent `revalidatePath` ou `revalidateTag`).
- De maniÃ¨re temporelle.

Prenons le cas oÃ¹ notre BDD serait partagÃ©e avec une autre application. Par exemple, de nouvelles tÃ¢ches arrivent dans la liste.

Il est possible de revalider les donnÃ©es tous les X secondes, minutes, heures. Pour cela, il est possible de spÃ©cifier cela via `revalidate` (depuis une route `handler`).

```tsx
//page.tsx ou layout.tsx
export const revalidate = 3600 // revalidate at most every hour
```

- ğŸ¶ Dans cet exercice, tu vas modifier manuellement le fichier `db.json`. Normalement (en production) les donnÃ©es ne devraient pas Ãªtre visibles dans la vue.
- Ajoute une revalidation toutes les 10 secondes.

Fichiers

- `exercises/todos/page.tsx`

## Aller plus loin

ğŸ“‘ Le lien vers la doc [https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating)

## Ils vont tâ€™aider

- **ğŸ¶ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ğŸ¤– Ash le Robot** : _Ash le Robot te donnera du code utile._
- **ğŸš€ Julia La roquette** : _Julia te donnera des dÃ©fis supplÃ©mentaires._
- **â›ï¸ Hulk le Marteau** : _Quand du code Ã  supprimer est prÃ©sent_
- **ğŸ‘¨â€âœˆï¸ Hugo le chef de projet** : _Va t'aider sur les spÃ©cifications du projet_

## ğŸœ Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20PRO&entry.1430994900=03.RSC%20Data%20fetch&entry.533578441=05%20Server%20actions).
